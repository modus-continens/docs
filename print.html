<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Modus Documentation</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="tutorial.html"><strong aria-hidden="true">2.</strong> Tutorial</a></li><li class="chapter-item expanded "><a href="syntax.html"><strong aria-hidden="true">3.</strong> Syntax</a></li><li class="chapter-item expanded "><a href="semantics.html"><strong aria-hidden="true">4.</strong> Semantics</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.</strong> Library</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="library/predicates/index.html"><strong aria-hidden="true">5.1.</strong> Predicates</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="library/predicates/image.html"><strong aria-hidden="true">5.1.1.</strong> Image</a></li><li class="chapter-item expanded "><a href="library/predicates/layer.html"><strong aria-hidden="true">5.1.2.</strong> Layer</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.1.3.</strong> Logic</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="library/predicates/logic/number.html"><strong aria-hidden="true">5.1.3.1.</strong> Number</a></li><li class="chapter-item expanded "><a href="library/predicates/logic/string.html"><strong aria-hidden="true">5.1.3.2.</strong> String</a></li><li class="chapter-item expanded "><a href="library/predicates/logic/semver.html"><strong aria-hidden="true">5.1.3.3.</strong> SemVer</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="library/operators/index.html"><strong aria-hidden="true">5.2.</strong> Operators</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="library/operators/image.html"><strong aria-hidden="true">5.2.1.</strong> Image</a></li><li class="chapter-item expanded "><a href="library/operators/layer.html"><strong aria-hidden="true">5.2.2.</strong> Layer</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="foundations.html"><strong aria-hidden="true">6.</strong> Foundations</a></li><li class="chapter-item expanded "><a href="cli/index.html"><strong aria-hidden="true">7.</strong> Command Line Tool</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Modus Documentation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/modus-continens/modus" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Modus is a language for building OCI/Docker container images. Modus uses logic programming to solve key pain points of Dockerfiles - no way to express interaction among parameters, inability to specify complex build workflows, difficult and inefficient parallelisation, bloated images, and costly maintenance. For more information, please follow the following links:</p>
<ul>
<li><a href="https://modus-continens.com">Modus website</a></li>
<li><a href="https://docs.modus-continens.com">Documentation</a></li>
<li><a href="https://play.modus-continens.com">Playground</a></li>
<li><a href="https://discord.gg/bXxwfVE9Kj">Discord community</a></li>
<li><a href="https://github.com/modus-continens/modus">GitHub</a></li>
</ul>
<p>Modus uses semantic versioning; until version 1.0 is declared, breaking changes are possible. The current version, 0.1, is a preview release. We welcome bug reports and feature requests submitted through <a href="https://github.com/mechtaev/modus/issues">GitHub Issues</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tutorial"><a class="header" href="#tutorial">Tutorial</a></h1>
<h2 id="installation"><a class="header" href="#installation">Installation</a></h2>
<p>Follow the <a href="https://modus-continens.com/get.html">installation instructions</a> on the website to download and install Modus.</p>
<h2 id="your-first-modusfile"><a class="header" href="#your-first-modusfile">Your First Modusfile</a></h2>
<p>Modusfiles are our version of Dockerfiles. They are a collection of rules that specify how to build images. We now demonstrate how to use Modus to build a simple rust application.</p>
<pre><code class="language-Modusfile">my_app(profile) :-
  (
    from(&quot;rust:alpine&quot;)::set_workdir(&quot;/usr/src/app&quot;),   # FROM rust:alpine; WORKDIR /usr/src/app
    copy(&quot;.&quot;, &quot;.&quot;),                                     # COPY . .
    cargo_build(profile)                                # calling into another predicate
  )::set_entrypoint(f&quot;./target/${profile}/my_app&quot;).     # ENTRYPOINT [&quot;./target/release/my_app&quot;]

cargo_build(&quot;debug&quot;) :- run(&quot;cargo build&quot;).             # RUN cargo build
cargo_build(&quot;release&quot;) :- run(&quot;cargo build --release&quot;). # RUN cargo build --release
</code></pre>
<p>Assuming that you are familiar with Dockerfiles, the meaning of the above Modusfile should be mostly easy to guess. In particular:</p>
<ul>
<li>
<p>The syntax is an extension of <a href="https://en.wikipedia.org/wiki/Datalog">Datalog</a> (which is itself a subset of Prolog), but you do not need to know either of those languages to write your own Modusfile.</p>
</li>
<li>
<p>Line-comments starts with <code>#</code>. In the above case, the equivalent instructions in Dockerfile have been written out for clarity using comments.</p>
</li>
<li>
<p>Modusfile consists of a series of rules of the form <code>HEAD :- BODY.</code>, where <code>HEAD</code> is a single literal, and <code>BODY</code> is an expression involving other literals.</p>
</li>
<li>
<p>A literal has the form <code>foo(arg1, arg2, ...)</code> where <code>foo</code> is the name of the predicate, and <code>arg1</code>, <code>arg2</code>, etc. are arguments. Examples of literals in the above file are <code>my_app(&quot;debug&quot;)</code>, <code>from(&quot;rust&quot;)</code>. Literals can also have no parameters, in which case you omit the parenthesis, like <code>my_app</code>.</p>
</li>
<li>
<p>Expression uses <code>,</code> to denote logical &quot;and&quot;, and <code>;</code> to denote logical &quot;or&quot;. Expressions can be nested with <code>()</code>, and can also have &quot;<code>::</code>&quot; operators that may change the behaviour of the modified expression in some way. A later section will discuss logic in Modus in more detail, but for now just think of <code>a, b</code> as &quot;do <code>a</code> then <code>b</code>&quot;, and think of <code>a; b</code> as &quot;do either of <code>a</code> or <code>b</code>, whichever works&quot;.</p>
</li>
</ul>
<p>Note that instead of writing <code>run(&quot;cargo build&quot;)</code> directly in <code>my_app</code>, we used a custom rule <code>cargo_build</code>, which we defined later, and, when defining <code>cargo_build</code>, we have separate definition for when the argument is <code>dev</code> and when it is <code>release</code>. To make this clearer, consider the line</p>
<pre><code class="language-Modusfile">cargo_build(&quot;debug&quot;) :- run(&quot;cargo build&quot;).
</code></pre>
<p>What this means is that <code>run(&quot;cargo build&quot;)</code> logically implies <code>cargo_build(&quot;debug&quot;)</code>. Given this definition, whenever Modus sees <code>cargo_build(&quot;debug&quot;)</code>, Modus replaces it with <code>run(&quot;cargo build&quot;)</code>.</p>
<p>The <code>set_workdir</code> operator takes in a path, and sets the working directory of its image operand. This changes subsequent resolution of relative paths, such as in the destination argument of <code>copy</code>. <code>set_entrypoint</code> simply overrides the entrypoint of an image.</p>
<p>To build a Modusfile, you just need to use the &quot;<code>modus build</code>&quot; command. The usage is fairly similar to <code>docker build</code>:</p>
<pre><code>modus build [-f &lt;Modusfile&gt;] &lt;CONTEXT&gt; &lt;QUERY&gt;
</code></pre>
<p><code>CONTEXT</code> is a directory containing any source file that you want to make available to Docker, just like the context directory in <code>docker build</code>. <code>QUERY</code> is a literal denoting what you want to build. You can use &quot;<code>-f &lt;Modusfile&gt;</code>&quot; to specify the Modusfile to build, and the default is <code>Modusfile</code> in the context directory.</p>
<p>In our case, we can use <code>my_app(&quot;debug&quot;)</code> as our query in order to build a debug image. However, we can also specify unbounded variables in our query. If we simply use <code>my_app(X)</code> as our query, Modus will build two images in parallel for us, one being the debug image and the other being the release image. You can think of it as saying &quot;For all X, as long as <code>my_app(X)</code> generates a valid image, build it&quot;. You can also go a step further and add parameters to select the rust channel, base distributions, etc. You can't specify a default for these parameters, but you can define versions of <code>my_app</code> that takes different numbers (including zero) of parameters, to simulate having a default. For example, by adding:</p>
<pre><code class="language-Modusfile">my_app :- my_app(&quot;release&quot;).
</code></pre>
<p>The query <code>my_app</code> will now build the release version, while you can still use <code>my_app(&quot;debug&quot;)</code> to build the debug version.</p>
<p>The attentive reader will have noticed that our Modusfile builds both a debug and a release image. Consider how you would do this with Dockerfiles — you would either need two separate Dockerfiles, each building one version, or do something with build arguments. It may not be a problem if you only have debug and release images, but it quickly become hard to manage, especially if you need to take separate steps depending on some arguments.</p>
<h2 id="intermediate-build-stages"><a class="header" href="#intermediate-build-stages">Intermediate Build Stages</a></h2>
<p>For our next step, we want to reduce the size of the final image by building the rust code in a separate stage, then starting a new image and copying the binary inside. This can be easily implemented in Modusfile as well. We will just need to add the following lines to our existing Modusfile, and use <code>trimmed_app</code> as our query instead:</p>
<pre><code class="language-Modusfile">trimmed_app(profile) :-
  (
    from(&quot;alpine&quot;),
    my_app(profile)::copy(f&quot;target/${profile}/my_app&quot;, &quot;.&quot;)
  )::set_entrypoint(&quot;./my_app&quot;).
</code></pre>
<p><code>image::copy(source, destination)</code> is an operator that allows you to copy files from another image to the current one. The <code>image</code> here can actually be any expression generating an image, so you could also &quot;inline&quot; <code>my_app</code> and write something like:</p>
<pre><code class="language-Modusfile">trimmed_app(profile) :-
  (
    from(&quot;alpine&quot;),
    (
      from(&quot;rust:alpine&quot;)::set_workdir(&quot;/usr/src/app&quot;),
      copy(&quot;.&quot;, &quot;.&quot;),
      cargo_build(profile)
    )::copy(f&quot;target/${profile}/my_app&quot;, &quot;.&quot;)
  )::set_entrypoint(&quot;./my_app&quot;).
</code></pre>
<p>Note that both <code>source</code> and <code>destination</code> can be relative paths. They will all be resolved sensibly based on respective the working directory.</p>
<h2 id="logic-in-modus"><a class="header" href="#logic-in-modus">Logic in Modus</a></h2>
<p>Not all predicates has to be about building. Since Modus is based on a logic programming language, it goes without saying that you can write more complicated Modusfile, which can do things like figure out which version of compiler to use depeneding on constraints on parameters, or take additional steps for debug builds, etc. Here is a quick rundown of some Modus patterns:</p>
<ul>
<li>Defining multiple rules for the same predicate with different parameters. We have already seen how this lets us &quot;select&quot; what cargo command to run.</li>
<li>Creating a dictionary by defining a set of constant rules for a predicate. For example:</li>
</ul>
<pre><code class="language-Modusfile">target_cc_flags(&quot;debug&quot;, &quot;-Og -fsanitize=address,undefined&quot;).
target_cc_flags(&quot;release&quot;, &quot;-O3&quot;).
target_cc_flags(&quot;fuzz&quot;, &quot;-Og -fsanitize=fuzzer,address,undefined -DFUZZING=1&quot;).

my_app(target) :-
  ...,
  target_cc_flags(target, flags),
  run(f&quot;make CFLAGS='${flags}' CXXFLAGS='${flags}'&quot;),
  ....
</code></pre>
<p>Note that rules with no body can be written as <code>HEAD.</code>, and is always true.</p>
<ul>
<li>Defining a predicate that &quot;restricts&quot; the set of input. This is necessary to make unbounded variables work. For example:</li>
</ul>
<pre><code class="language-Modusfile">rust_channel(channel) :-
  channel = &quot;stable&quot;; channel = &quot;nightly&quot;; channel = &quot;beta&quot;.

# or

rust_channel(&quot;stable&quot;).
rust_channel(&quot;nightly&quot;).
rust_channel(&quot;beta&quot;).

my_app(channel) :-
  from(&quot;rust:alpine&quot;),
  rust_channel(channel),
  run(f&quot;rustup run ${channel} cargo build&quot;).
</code></pre>
<p>Without <code>rust_channel(channel)</code>, the query <code>my_app(X)</code> would fail, because it is not possible to build an infinite set of images. With the predicate to limit the values of <code>X</code>, a query like <code>my_app(X)</code> will build 3 images, each with a different version of rust.</p>
<h2 id="where-to-go-from-here"><a class="header" href="#where-to-go-from-here">Where to go from here…</a></h2>
<p>Now that you have learned the basics of Modus, you can go ahead and read the rest of the documentation, which dive deeper into how everything works exactly (groundness, predicate kinds, etc), as well as other built-in predicates and operators like <code>number_{gt,lt,eq,geq,leq}</code>, string parsing and manipulation, operators to set environment variables, temproarily changing the working directory with <code>in_workdir</code>, squashing image layers with <code>::merge</code>, etc.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="grammar"><a class="header" href="#grammar">Grammar</a></h1>
<p>A Modus build srcipt is a sequence of facts and rules. A fact is of the form</p>
<pre><code>&lt;fact&gt; ::= &lt;head&gt; &quot;.&quot;
</code></pre>
<p>A rule is of the form </p>
<pre><code>&lt;rule&gt; ::= &lt;head&gt; &quot;:-&quot; &lt;body&gt; &quot;.&quot;
</code></pre>
<p>The head of a fact or a rule is a <code>&lt;literal&gt;</code> of the form</p>
<pre><code>&lt;literal&gt; ::= &lt;identifier&gt; &quot;(&quot; &lt;arg_list&gt; &quot;)&quot;
            | &lt;identifier&gt;
</code></pre>
<p>where <code>&lt;identifier&gt;</code> is a non-empty alpha-numeric string, not starting with a number, and possibly containing <code>_</code>; <code>&lt;arg_list&gt;</code> is a comma-separated list of terms.</p>
<p>A term is either a variable or a string literal. A variable is represented as an <code>&lt;identifier&gt;</code>; string literals are described in <a href="syntax.html#string-literals">String Literals</a>.</p>
<p><code>a(&quot;b&quot;, _c)</code> and <code>foo</code> are examples of syntactically valid literals.</p>
<p>The body of a rule is an expression defined as follows:</p>
<pre><code>&lt;expression&gt; ::= &lt;literal&gt;
               | &lt;unification&gt;
               | &lt;expression&gt; &quot;::&quot; &lt;operator&gt;
               | &lt;expression&gt; &quot;,&quot; &lt;expression&gt;
               | &lt;expression&gt; &quot;;&quot; &lt;expression&gt;
               | &quot;(&quot; &lt;expression&gt; &quot;)&quot;
               | !&lt;expression&gt;
</code></pre>
<p>A unification asserts the equality of two terms (which could be variables):</p>
<pre><code>&lt;unification&gt; ::= &lt;term&gt; &quot;=&quot; &lt;term&gt;
                | &lt;term&gt; &quot;!=&quot; &lt;term&gt;
</code></pre>
<p>Operators have the same grammar as literals.</p>
<p>The following are examples of syntactically valid expressions:</p>
<ul>
<li><code>a(&quot;b&quot;, _c)</code></li>
<li><code>a = &quot;foo&quot;</code></li>
<li><code>a(&quot;b&quot;, _c)::b(_c)</code></li>
<li><code>a::b</code></li>
<li><code>a, b(&quot;c&quot;)</code></li>
<li><code>(a; b), c</code></li>
<li><code>!(a(X), b(X))</code></li>
<li><code>&quot;1.0.1&quot; = version</code></li>
</ul>
<h2 id="full-ebnf"><a class="header" href="#full-ebnf">Full EBNF</a></h2>
<pre><code>&lt;fact&gt; ::= &lt;head&gt; &quot;.&quot;
&lt;rule&gt; ::= &lt;head&gt; &quot;:-&quot; &lt;body&gt; &quot;.&quot;
&lt;head&gt; ::= &lt;literal&gt;
&lt;body&gt; ::= &lt;expression&gt;
&lt;literal&gt; ::= &lt;identifier&gt; &quot;(&quot; &lt;arg_list&gt; &quot;)&quot;
            | &lt;identifier&gt;
&lt;operator&gt; ::= &lt;literal&gt;
&lt;expression&gt; ::= &lt;literal&gt;
               | &lt;unification&gt;
               | &lt;expression&gt; &quot;::&quot; &lt;operator&gt;
               | &lt;expression&gt; &quot;,&quot; &lt;expression&gt;
               | &lt;expression&gt; &quot;;&quot; &lt;expression&gt;
               | &quot;(&quot; &lt;expression&gt; &quot;)&quot;
               | !&lt;expression&gt;
&lt;unification&gt; ::= &lt;term&gt; &quot;=&quot; &lt;term&gt;
                | &lt;term&gt; &quot;!=&quot; &lt;term&gt;

&lt;arg_list&gt; ::= &lt;term&gt; { &quot;,&quot; &lt;term&gt; }
&lt;term&gt; ::= &lt;variable&gt; | '&quot;' &lt;char_string&gt; '&quot;' | &lt;format_string_term&gt;
&lt;variable&gt; ::= &lt;identifier&gt;
&lt;format_string_term&gt; ::= 'f&quot;' { &lt;char_string&gt; | &lt;interpolation&gt; } '&quot;'
&lt;interpolation&gt; ::= &quot;${&quot; &lt;variable&gt; &quot;}&quot;

&lt;char_string&gt; ::= { &lt;char&gt; }
&lt;identifier&gt; ::= ( &lt;letter&gt; | &quot;_&quot; ) [ &lt;alphanumeric_with_underscore&gt; ]
&lt;alphanumeric_with_underscore&gt; ::= { &lt;letter&gt; | &lt;digit&gt; | &quot;_&quot; }
&lt;alphanumeric&gt; ::= { &lt;letter&gt; | &lt;digit&gt; }
&lt;letter&gt; ::= &quot;A&quot; | &quot;B&quot; | &quot;C&quot; | &quot;D&quot; | &quot;E&quot; | &quot;F&quot; | &quot;G&quot;
       | &quot;H&quot; | &quot;I&quot; | &quot;J&quot; | &quot;K&quot; | &quot;L&quot; | &quot;M&quot; | &quot;N&quot;
       | &quot;O&quot; | &quot;P&quot; | &quot;Q&quot; | &quot;R&quot; | &quot;S&quot; | &quot;T&quot; | &quot;U&quot;
       | &quot;V&quot; | &quot;W&quot; | &quot;X&quot; | &quot;Y&quot; | &quot;Z&quot; | &quot;a&quot; | &quot;b&quot;
       | &quot;c&quot; | &quot;d&quot; | &quot;e&quot; | &quot;f&quot; | &quot;g&quot; | &quot;h&quot; | &quot;i&quot;
       | &quot;j&quot; | &quot;k&quot; | &quot;l&quot; | &quot;m&quot; | &quot;n&quot; | &quot;o&quot; | &quot;p&quot;
       | &quot;q&quot; | &quot;r&quot; | &quot;s&quot; | &quot;t&quot; | &quot;u&quot; | &quot;v&quot; | &quot;w&quot;
       | &quot;x&quot; | &quot;y&quot; | &quot;z&quot;
&lt;digit&gt; ::= &quot;0&quot; | &quot;1&quot; | &quot;2&quot; | &quot;3&quot; | &quot;4&quot; | &quot;5&quot; | &quot;6&quot; | &quot;7&quot; | &quot;8&quot; | &quot;9&quot;
</code></pre>
<h2 id="string-literals"><a class="header" href="#string-literals">String Literals</a></h2>
<p>There exist two types of string literals:</p>
<ul>
<li>Normal strings</li>
<li>Formatted strings</li>
</ul>
<p>Normal strings are sequences of characters surrounded with double quotes, in which <code>&quot;</code> needs to be escaped and <code>\</code> is used as the escape characted. Specifically, the following characters are escaped: <code>\&quot;</code>, <code>\\</code>, <code>\n</code>, <code>\r</code>, <code>\t</code>, <code>\\</code>, <code>\0</code>. To break a single-line string to multiple lines, use a string continuation, a newline character preceded with <code>\</code>. Below are examples of valid string literals:</p>
<ul>
<li><code>&quot;abc&quot;</code></li>
<li><code>&quot;a\nb&quot;</code></li>
<li><code>&quot;\&quot;abc\&quot;&quot;</code></li>
<li>
<pre><code>&quot;hello,\
 world&quot;
</code></pre>
</li>
</ul>
<p>Formatted strings are just like normal strings, but they starts with the letter <code>f</code> before the first quote symbol, and <code>$</code> can be escaped. Below are examples of valid string literals:</p>
<ul>
<li><code>f&quot;abc&quot;</code></li>
<li><code>f&quot;10\$&quot;</code></li>
<li><code>f&quot;hello, ${name}&quot;</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="semantics"><a class="header" href="#semantics">Semantics</a></h1>
<p>Given a build script and a query, Modus performs two operations:</p>
<ol>
<li>computes the build <a href="https://en.wikipedia.org/wiki/Directed_acyclic_graph">Directed acyclic graph (DAG)</a> using an extended <a href="https://en.wikipedia.org/wiki/Datalog">Datalog</a> solver;</li>
<li>executes the build in parallel using <a href="https://github.com/moby/buildkit">BuildKit</a>.</li>
</ol>
<p>The build DAG is a graph that describes dependencies between build operations. It is a DAG, and not a set of trees, because some intermediate images can be shared and built only once. The DAG is computed by a Datalog solver as the minimal proof of the build target from true facts representing either existing images, or intrinsics like <code>run</code> which add build steps. The build DAG is constructed statically, i.e. the values of the variables do not depend on the results of build execution. Particularities of DAG construction are described in <a href="./static.html">Static</a>.</p>
<p>After the build DAG is computed, it is transformed into a <a href="https://github.com/moby/buildkit">BuildKit</a> representation. Then, BuildKit executes build subtrees in parallel to construct the target images. Particularities of build execution are described in <a href="./runtime.html">Runtime</a>.</p>
<h2 id="predicate-kinds"><a class="header" href="#predicate-kinds">Predicate Kinds</a></h2>
<p>In a literal such as <code>a(b, &quot;c&quot;)</code>, we refer to <code>a</code> as the predicate name. There exist predicates of three and only three kinds:</p>
<ul>
<li>image predicates;</li>
<li>layer predicates;</li>
<li>logic predicates.</li>
</ul>
<p>An <em>image predicate</em> is one of the following:</p>
<ul>
<li>builtin predicate <code>from</code>;</li>
<li>a predicate, in all definitions <code>&lt;head&gt; :- &lt;body&gt;</code> of which, the body is an image expression.</li>
</ul>
<p>An <em>image expression</em> is defined as follows:</p>
<ul>
<li>an image literal, which is an application of an image predicate, is an image expression;</li>
<li>an application of an operator to an image expression (<code>&lt;expression&gt; &quot;::&quot; &lt;operator&gt;</code>) is an image expression, except for the <code>::copy</code> operator;</li>
<li><code>&lt;expression1&gt; &quot;,&quot; &lt;expression2&gt;</code> is an image expression iff 
<ul>
<li>either <code>&lt;expression1&gt;</code> is an image expression, and <code>&lt;expression2&gt;</code> is not an image expression.</li>
<li>or <code>&lt;expression1&gt;</code> is a logic expression and <code>&lt;expression2&gt;</code> is an image expression.</li>
</ul>
</li>
<li><code>&lt;expression1&gt; &quot;;&quot; &lt;expression2&gt;</code> is an image expression iff both <code>&lt;expression1&gt;</code> and <code>&lt;expression2&gt;</code> are image expressions.</li>
</ul>
<p>In the following example, <code>a</code> is an image predicate, and <code>b</code> is not:</p>
<pre><code>a :-
    from(&quot;ubuntu&quot;),
    run(&quot;apt-get update&quot;).
    
b(X) :- X = &quot;a&quot;.
</code></pre>
<p>A <em>layer predicate</em> is one of the following:</p>
<ul>
<li>the builtin predicate <code>run</code>;</li>
<li>the builtin predicate <code>copy</code>;</li>
<li>a predicate, in all definitions <code>&lt;head&gt; :- &lt;body&gt;</code> of which, the body is a layer expression.</li>
</ul>
<p>A <em>layer expression</em> is defined as follows:</p>
<ul>
<li>a layer literal, which is an application of a layer predicate, is a layer expression;</li>
<li>an application of an operator to a layer expression (<code>&lt;expression&gt; &quot;::&quot; &lt;operator&gt;</code>) is a layer expression;</li>
<li><code>&lt;expression1&gt; &quot;,&quot; &lt;expression2&gt;</code> is a layer expressions iff either:
<ul>
<li>both <code>&lt;expression1&gt;</code> and <code>&lt;expression2&gt;</code> are layer expressions.</li>
<li>or <code>&lt;expression1&gt;</code> is a logic expression and <code>&lt;expression2&gt;</code> is a layer expression.</li>
</ul>
</li>
<li><code>&lt;expression1&gt; &quot;;&quot; &lt;expression2&gt;</code> is a layer expression iff both <code>&lt;expression1&gt;</code> and <code>&lt;expression2&gt;</code> are layer expressions.</li>
<li>an application of the operator <code>::copy</code> to an image literal is a layer expression;</li>
</ul>
<p>In the following example, <code>a</code> is a layer predicate, and <code>b</code> is not:</p>
<pre><code>a :- (from(&quot;ubuntu&quot;), run(&quot;apt-get update&quot;))::copy(&quot;/etc/hosts&quot;, &quot;.&quot;).
    
b(X) :- X = &quot;a&quot;.
</code></pre>
<p>A <em>logic predicate</em> is one of the following:</p>
<ul>
<li>a buildin predicate, except for <code>from</code>, <code>run</code> and <code>copy</code>;</li>
<li>a predicate, in all definitions <code>&lt;head&gt; :- &lt;body&gt;</code> of which, the body is a logic expression.</li>
</ul>
<p>A <em>logic expression</em> is defined as follows:</p>
<ul>
<li>a logic literal, which is an application of a logic predicate, is a logic expression;</li>
<li>a unification is a logic expression;</li>
<li>an application of an operator to a logic expression (<code>&lt;literal&gt; &quot;::&quot; &lt;operator&gt;</code>) is a logic expression.</li>
<li><code>&lt;expression1&gt; &quot;,&quot; &lt;expression2&gt;</code> and <code>&lt;expression1&gt; &quot;;&quot; &lt;expression2&gt;</code> are logic expressions iff both <code>&lt;expression1&gt;</code> and <code>&lt;expression2&gt;</code> are logic expressions.</li>
<li>the negation of a logic expression</li>
</ul>
<p>In the following example, <code>a</code> and <code>a_prime</code> are logic predicates, but <code>b</code> is not:</p>
<pre><code>a(Y) :- semver_geq(Y, &quot;1.2.3&quot;).
a_prime(Y) :- !a(Y).
    
b(X) :- X = &quot;a&quot;, from(&quot;ubuntu&quot;).
</code></pre>
<h2 id="negation"><a class="header" href="#negation">Negation</a></h2>
<p>Expressions can be negated, which acts as a logical check. Here are some examples of expressions using negation:</p>
<ul>
<li><code>!(a(X), b)</code></li>
<li><code>!(foo(X) ; bar(Y) ; !baz(X)), lit(X)</code>
Note that X is constrained with all of <code>foo(X)</code>, the nested negation <code>baz(X)</code> and the 
positive literal <code>lit(X)</code>.</li>
</ul>
<p>A negated expression asserts that the positive expression fails to be proved, i.e. we cannot 
construct a proof tree of it.
The variables of a negated expression must be grounded (e.g. through some other literal) or must be 
an anonymous variable.</p>
<p>This is an example of a Modusfile using negation:</p>
<pre><code>app(X) :-
    (
        windows(X),
        from(&quot;jturolla/failing-container&quot;)
    ;
        !windows(X),
        from(X),
        run(&quot;echo hello-world&quot;)
    ).
    
windows(&quot;...&quot;).
</code></pre>
<p>Usually, negation can be thought of as falsehood, however, there is an important distinction between proving
falsehood and <em>Negation as Failure</em> (NAF). 
If the fact <code>windows(c1).</code> is not present (for some constant <code>c1</code>), we say <code>!windows(c1)</code> succeeds.
So we are not truly <em>inferring</em> <code>!windows(c1)</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="predicates"><a class="header" href="#predicates">Predicates</a></h1>
<p>Predicate are used to encapsulate build logic. Predicates in Modus belong to one of the three kinds: image predicates, layer predicates and logic predicates. <a href="library/predicates/./image.html">Image predicates</a> create new images, e.g. the predicate <code>from</code>, as well as any predicates that adds further layers upon a <code>from</code>. <a href="library/predicates/./layer.html">Layer predicates</a> adds new layers on tops of an image, and can not itself be built, e.g. <code>run</code> or <code>copy</code>. <a href="library/predicates/./logic/README.html">Logic predicates</a> does neither, can be used anywhere, but can not be built on its own. The kind of a predicate determines where it can be used. For example, a rule body can not contain more than one image predicates, nor can layer predicates appear before image predicates. The kind of a user-defined predicate is inferred automatically, while the kind of a builtin predicate is pre-defined.</p>
<p>Builtin predicates have Prolog-like signatures that specify which parameters have to be initialised:</p>
<pre><code>predicate(?Variable1, +Variable2, -Variable3)
</code></pre>
<p>where</p>
<ul>
<li><code>?</code> means: This variable can be either instantiated or not. Both ways are possible.</li>
<li><code>+</code> means: This variable is an input to the predicate. As such it must be instantiated.</li>
<li><code>-</code> means: This variable is an output to the predicate. It is usually non-instantiated, but may be if you want to check for a specific &quot;return value&quot;.</li>
</ul>
<p>For example, <code>run</code> has the signature <code>run(+cmdline)</code>, which means that the argument has to be initialised.</p>
<table><thead><tr><th>Predicate</th><th>Kind</th><th>Description</th></tr></thead><tbody>
<tr><td><a href="library/predicates/./image.html#from"><code>from</code></a></td><td>Image</td><td>Refer to existing local/registry image by its name</td></tr>
<tr><td><a href="library/predicates/./layer.html#run"><code>run</code></a></td><td>Layer</td><td>Execute shell command</td></tr>
<tr><td><a href="library/predicates/./layer.html#copy"><code>copy</code></a></td><td>Layer</td><td>Copy local file/directory</td></tr>
<tr><td><a href="library/predicates/./logic/number.html"><code>number_eq</code></a></td><td>Logic</td><td><code>=</code> for numbers</td></tr>
<tr><td><a href="library/predicates/./logic/number.html"><code>number_gt</code></a></td><td>Logic</td><td><code>&gt;</code> for numbers</td></tr>
<tr><td><a href="library/predicates/./logic/number.html"><code>number_lt</code></a></td><td>Logic</td><td><code>&lt;</code> for numbers</td></tr>
<tr><td><a href="library/predicates/./logic/number.html"><code>number_geq</code></a></td><td>Logic</td><td><code>&gt;=</code> for numbers</td></tr>
<tr><td><a href="library/predicates/./logic/number.html"><code>number_leq</code></a></td><td>Logic</td><td><code>&lt;=</code> for numbers</td></tr>
<tr><td><a href="library/predicates/./logic/string.html#string_concat"><code>string_concat</code></a></td><td>Logic</td><td>Concatenate strings</td></tr>
<tr><td><a href="library/predicates/./logic/string.html#string_length"><code>string_length</code></a></td><td>Logic</td><td>Compute string length</td></tr>
<tr><td><a href="library/predicates/./logic/semver.html#semver_exact"><code>semver_exact</code></a></td><td>Logic</td><td>Equality with compatibility check for SemVer versions</td></tr>
<tr><td><a href="library/predicates/./logic/semver.html#semver_op"><code>semver_gt</code></a></td><td>Logic</td><td><code>&gt;</code> for SemVer versions</td></tr>
<tr><td><a href="library/predicates/./logic/semver.html#semver_op"><code>semver_lt</code></a></td><td>Logic</td><td><code>&lt;</code> for SemVer versions</td></tr>
<tr><td><a href="library/predicates/./logic/semver.html#semver_op"><code>semver_geq</code></a></td><td>Logic</td><td><code>&gt;=</code> for SemVer versions</td></tr>
<tr><td><a href="library/predicates/./logic/semver.html#semver_op"><code>semver_leq</code></a></td><td>Logic</td><td><code>&lt;=</code> for SemVer versions</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="image"><a class="header" href="#image">Image</a></h1>
<ul>
<li>
<p><a name="from"></a><code>from(+imageref)</code>: Refer to existing local/registry image by its name.</p>
<p><code>imageref</code> follows standard Docker image reference syntax, so it can contain a registry, a tag, or it can be a digest.</p>
<p>This is equivalent to <code>FROM</code> in Dockerfile.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="layer"><a class="header" href="#layer">Layer</a></h1>
<ul>
<li>
<p><a name="run"></a><code>run(+command)</code>: Run a shell command.</p>
<p><code>command</code> should be a string containing a shell script. At runtime, the script will be executed with <code>/bin/sh -c</code>.</p>
<p>This is equivalent to <code>RUN</code> in Dockerfile.</p>
</li>
<li>
<p><a name="copy"></a><code>copy(+src, +dst)</code>: Copy local file/directory.</p>
<p>Existing files already in the image will be overwritten in the new layer, and directories will be copied recursively. Any non-existant parent directories will be created.</p>
<p>This is equivalent to <code>COPY</code> in Dockerfile without a <code>--from</code> option. Following Docker's behavior, if <code>src</code> is a directory, <strong>the content of <code>src</code></strong> is copied into <code>dst</code>, but not <code>src</code> itself. This means that <code>copy(&quot;dir&quot;, &quot;/&quot;)</code> basically means <code>cp -r dir/* /</code>.</p>
<p>If <code>dst</code> is a relative path, it is resolved based on the current image's working directory. <code>src</code> must be a relative path, and must not be outside the build context.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="number"><a class="header" href="#number">Number</a></h1>
<ul>
<li><code>number_OP(+a, +b)</code>: compare numbers, resolves if <code>a</code> OP <code>b</code> is true. Valid OPs are:
<ul>
<li><code>eq</code>: a = b</li>
<li><code>gt</code>: a &gt; b</li>
<li><code>lt</code>: a &lt; b</li>
<li><code>geq</code>: a &gt;= b</li>
<li><code>leq</code>: a &lt;= b</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="string"><a class="header" href="#string">String</a></h1>
<ul>
<li>
<p><a name="string_concat"></a><code>string_concat(?a, ?b, ?res)</code>: Concatenate two strings.</p>
<p>At least two arguments must be grouneded. Resolves if <code>a</code> + <code>b</code> = <code>res</code>. If one of the argument is ungrounded, this predicate constrains it so that the statement is true, by either concating the two strings or removing a prefix or suffix from <code>res</code>.</p>
<p>f-strings act as a syntatic sugar for this predicate: <code>X = f&quot;${a}(content of b)&quot;</code>, <code>X = f&quot;(content of a)${b}</code> or <code>X = f&quot;${a}${b}&quot;</code> is equivalent to <code>string_concat(a, b, X)</code>.</p>
<p>Due to the limitation of our logic resolution algorithm, this predicate can not be part of a recursion. For example, <code>a(X) :- string_concat(&quot;a&quot;, Y, X), a(Y)</code> is not allowed.</p>
</li>
<li>
<p><a name="string_length"></a><code>string_length(+str, -len)</code>: Get the length of a string.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="semver"><a class="header" href="#semver">SemVer</a></h1>
<ul>
<li>
<p><a name="semver-op"></a> <code>semver_OP(+a, +b)</code>: compare semver versions, resolves if <code>a</code> OP <code>b</code> is true. Valid OPs are the same as those for <a href="library/predicates/logic/number.html"><code>number_OP</code></a>, except there is no <code>semver_eq</code>.</p>
</li>
<li>
<p><a name="semver-exact"></a> <code>semver_exact(+a, +b)</code>:  <code>=I.J.K</code> means exactly the version <code>I.J.K</code>; <code>=I.J</code> means equivalent to <code>&gt;=I.J.0, &lt;I.(J+1).0</code>; <code>=I</code> means equivalent to <code>&gt;=I.0.0, &lt;(I+1).0.0</code>.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="operators"><a class="header" href="#operators">Operators</a></h1>
<p>Operators begin with <code>::</code>; they can be applied to expressions to control the build process.</p>
<table><thead><tr><th>Operator</th><th>From</th><th>To</th><th>Description</th></tr></thead><tbody>
<tr><td><a href="library/operators/./image.html#copy"><code>::copy</code></a></td><td>Image</td><td>Layer</td><td>Copy file/directory to current image</td></tr>
<tr><td><a href="library/operators/./image.html#simple-set"><code>::set_env</code></a></td><td>Image</td><td>Image</td><td>Set environment variable</td></tr>
<tr><td><a href="library/operators/./image.html#simple-set"><code>::set_entrypoint</code></a></td><td>Image</td><td>Image</td><td>Set entrypoint</td></tr>
<tr><td><a href="library/operators/./image.html#simple-set"><code>::set_cmd</code></a></td><td>Image</td><td>Image</td><td>Set image &quot;CMD&quot;</td></tr>
<tr><td><a href="library/operators/./image.html#simple-set"><code>::set_workdir</code></a></td><td>Image</td><td>Image</td><td>Set current working directory</td></tr>
<tr><td><a href="library/operators/./image.html#simple-set"><code>::set_user</code></a></td><td>Image</td><td>Image</td><td>Set user</td></tr>
<tr><td><a href="library/operators/./image.html#append_path"><code>::append_path</code></a></td><td>Image</td><td>Image</td><td>Append PATH variable</td></tr>
<tr><td><a href="library/operators/./layer.html#in_workdir"><code>::in_workdir</code></a></td><td>Layer</td><td>Layer</td><td>Specify working directory for layer commands</td></tr>
<tr><td><a href="library/operators/./layer.html#in_env"><code>::in_env</code></a></td><td>Layer</td><td>Layer</td><td>Specify environment variables for layer commands</td></tr>
<tr><td><a href="library/operators/./layer.html#merge"><code>::merge</code></a></td><td>Layer</td><td>Layer</td><td>Merge layers</td></tr>
</tbody></table>
<!-- | [`::set_user`](./operators/image.md#set_user) | Image | Set user | -->
<!-- | [`::set_expose`](./operators/image.md#set_expose) | Image | Set exposed port | -->
<!-- | [`::set_cmd`](./operators/image.md#set_cmd) | Image | Set default arguments to entrypoint | -->
<!-- | [`::set_volume`](./operators/image.md#set_volume) | Image | Set volume | -->
<!-- | [`::set_label`](./operators/image.md#set_label) | Image | Add metadata to image | -->
<!-- | [`::set_stopsignal`](./operators/image.md#set_stopsignal) | Image | Set stop signal | -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="image-1"><a class="header" href="#image-1">Image</a></h1>
<ul>
<li>
<p><a name="copy"></a><code>::copy(+src, +dst)</code>: Copy file/directory from another image.</p>
<p>Existing files already in the current image will be overwritten in the new layer, and directories will be copied recursively. Any non-existant parent directories will be created.</p>
<p>This is equivalent to <code>COPY --from=src_image</code> in Dockerfile. Following Docker's behavior, if <code>src</code> is a directory, the content of <code>src</code> is copied into <code>dst</code>, but not <code>src</code> itself. This means that <code>copy(&quot;dir&quot;, &quot;/&quot;)</code> is equivalent to <code>cp -r dir/* /</code>.</p>
<p>If <code>src</code> is a relative path, it is resolved based on the source image's working directory. If <code>dst</code> is a relative path, it is resolved based on the current image's working directory.</p>
</li>
<li>
<p><a name="append-path"></a><code>::append_path(+path)</code>: append string to the PATH environment variable.</p>
</li>
<li>
<p><a name="simple-set"></a><code>::set_env(+key, +value)</code>, <code>::set_entrypoint(+str_or_array)</code>, <code>::set_cmd(+array)</code>, <code>::set_workdir(+dir)</code>, <code>::set_user(+username)</code>: Set image properties.</p>
<p><code>::set_workdir</code> also allows specifying a relative path based on the input image's working directory. This will be resolved to an absolute path.</p>
<p><code>::set_entrypoint</code> will clear any command the image has, to be consistent with the <code>ENTRYPOINT</code> command in Dockerfile.</p>
<p>Example:</p>
<pre><code class="language-Modusfile">app :-
  (
    from(&quot;alpine&quot;),
    copy(&quot;./app&quot;, &quot;/&quot;),
    copy(&quot;./entrypoint.sh&quot;, &quot;/&quot;)
  )::set_entrypoint(&quot;/entrypoint.sh&quot;)
   ::set_cmd([&quot;start&quot;]).
</code></pre>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="layer-1"><a class="header" href="#layer-1">Layer</a></h1>
<ul>
<li>
<p><a name="in_workdir"></a><code>::in_workdir(+dir)</code>: Temporary change the image's working directory, affecting any operations inside the operator.</p>
</li>
<li>
<p><a name="in_env"></a><code>::in_env(+key, +value)</code>: Temporary set environment variable, affecting any operations inside the operator.</p>
</li>
<li>
<p><a name="merge"></a><code>::merge</code>: Squash anything inside into one image layer.</p>
<p>The only allowed operations inside are <code>run</code>, <code>copy</code> and <code>::copy</code>. This can improve image size if operations overwrite each other.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="foundations"><a class="header" href="#foundations">Foundations</a></h1>
<p>Container images are built on top of base images by copying information from other images and intacting with the environment. Modus uses decidable logic programming to concisely capture and efficiently resolve dependencies between images and to encapluate environmental interactions with predicates and operators. This section discusses the logic programming foundations of Modus. You do not need to understand these foundations to use, and profit from, Modus.</p>
<h2 id="design-principles"><a class="header" href="#design-principles">Design Principles</a></h2>
<ul>
<li><em>Maintainability</em>: make build definitions maintainable by enabling modularity, code reuse and dependency resolution.</li>
<li><em>Efficiency</em>: make builds efficient by automatic parallelisation and fine-grained caching; provide tools for optimising the image size.</li>
<li><em>Expressiveness</em>: enable the user to express complex build workflows.</li>
<li><em>Simplicity</em>: provide minimalistic syntax and well-defined, non-Turing-complete semantics for build definitions.</li>
</ul>
<h2 id="container-image-build-model"><a class="header" href="#container-image-build-model">Container Image Build Model</a></h2>
<p>A <a href="https://opencontainers.org/">Docker/OSI container image</a> consists of a set of layers combined using a <a href="https://en.wikipedia.org/wiki/Union_mount">union mount filesystem</a>. To build an image, the user specifies the parent image and defines operations that are executed on top of the parent image to form new layers. The most common operations are copying local files into the container and executing shell commands.</p>
<p>Another important operation which enables <a href="https://docs.docker.com/develop/develop-images/multistage-build/">multi-stage builds</a> is copying files from another image. A multi-stage build can be visualised as the following graph. Each instruction in this graph creates a new filesystem layer. Instructions are specified using Dockerfile's notation: <code>FROM</code> defines the parent image, <code>COPY</code> copies local files, <code>RUN</code> executes shell command, and <code>COPY --from</code> copies files from another container.</p>
<p><img src="build_model.svg" alt="Container Image Build Model" /></p>
<p>The key insight of Modus is that the resolution of dependencies between images in this build model maps to <a href="https://en.wikipedia.org/wiki/Horn_clause">Horn clauses</a>, logical formulas in the form \( u \leftarrow (p \wedge q\ \wedge ... \wedge\ t) \). Particularly, container images correspond to logical facts, build rules are logical rules that derive new facts from existing facts, and the build graph is a minimal proof of the fact representing the build target from the facts representing existing images.</p>
<p>Consider the following recursive build script:</p>
<pre><code class="language-Modusfile">a(mode) :-
    (
        mode = &quot;production&quot;,
        from(&quot;alpine&quot;),
        a(&quot;development&quot;)::copy(&quot;/app&quot;, &quot;/app&quot;)
    ;
        mode = &quot;development&quot;,
        from(&quot;gcc&quot;),
        copy(&quot;.&quot;, &quot;/app&quot;),
        run(&quot;cd /app &amp;&amp; make&quot;)
    )::set_workdir(&quot;/app&quot;).
</code></pre>
<p>For the query <code>a(X)</code>, where <code>X</code> is a variable, Modus computes the following build trees:</p>
<pre><code>a(&quot;production&quot;)
╞══ from(&quot;alpine&quot;)
└── a(&quot;development&quot;)::copy(&quot;/app&quot;, &quot;/app&quot;)
    ╞══ from(&quot;gcc&quot;)
    ├── copy(&quot;.&quot;, &quot;/app&quot;)
    └── run(&quot;cd /app &amp;&amp; make&quot;)
a(&quot;development&quot;)
╞══ from(&quot;gcc&quot;)
├── copy(&quot;.&quot;, &quot;/app&quot;)
└── run(&quot;cd /app &amp;&amp; make&quot;)
</code></pre>
<p>The subtree <code>a(&quot;development&quot;)</code> of the two trees is shared; it is only built once.</p>
<h2 id="datalog"><a class="header" href="#datalog">Datalog</a></h2>
<p>Datalog is a decidable fragment of Horn clauses. A good overview of Datalog is given in the following article:</p>
<p><em><a href="https://ieeexplore.ieee.org/document/43410">What You Always Wanted to Know About Datalog (And Never Dared to Ask)</a></em><br>
Stefano Ceri, Georg Gottlob, Letizia Tanca<br>
IEEE TKDE 1989</p>
<p>Modus uses Datalog because it is:</p>
<ul>
<li>declarative, the success of solving does not depend on the ordering of clauses;</li>
<li>expressive;</li>
<li>decidable, so it can always generate a minimal proof.</li>
</ul>
<p>Thus, Datalog presents a sweet spot between expressiveness and computatibility, which is important for a build system. Standard Datalog, despite its suitability for addressing their core dependency resolution problem, does not capture a container build environmental dependencies. To solve this problem, Modus extends Datalog with build-specific predicates and build parameters via ungrounded variables. Modus supports two Datalog extensions, namely builtin predicates described in <a href="./library/predicates/">Predicates</a> and non-grounded variables. To realise these extensions, Modus uses a custom top-down Datalog solver for generating proofs.</p>
<h3 id="builtin-predicates"><a class="header" href="#builtin-predicates">Builtin Predicates</a></h3>
<p>Dependency resolution is only part of the story. Container builds must also interact with the environment. Predicates elegantly capture these interactions. We have equipped Modus with a library of built-in predicates to handle these interactions. For example, the <code>semver_*</code> predicates define software version comparison as per the (SemVer)[https://semver.org/] specification.  For example, the following fact is true: <code>semver_lt(&quot;1.0.3&quot;,&quot;1.1.0&quot;)</code>, where <code>lt</code> means <code>&lt;</code>.</p>
<p>The key difficulty of adding built-in predicates to Datalog is that built-in predicates such as <code>semver_lt</code> are infinite relations, which require special handling to retain Datalog's decidability. We support built-in predicates by deferring the evaluation of a built-in predicate until the arguments of this predicate are bound to constants.</p>
<p>Since not all arguments of a predicate have to be bound to a constant during evaluation, e.g. if an argument depends on the other arguments, builtin predicates in Modus have Prolog-like signatures that specify which parameters have to be initialised (see <a href="./library/predicates/index.html">Predicates</a>). <!-- FIXME: https://github.com/rust-lang/mdBook/issues/984 --></p>
<h3 id="non-grounded-variables"><a class="header" href="#non-grounded-variables">Non-Grounded Variables</a></h3>
<p>Build systems often use parameters that are passed by the user when they launch a build. Dockerfiles allow users to specify arbitrary parameters when launching a target's build using the <code>--build-arg</code> option. For example, a user may want to parameretise <code>app</code>'s image build with the parameter <code>cflags</code> to control complation flags:</p>
<pre><code class="language-Modusfile">app(cflags) :-
  from(&quot;gcc:latest&quot;),
  copy(&quot;.&quot;, &quot;.&quot;),
  run(f&quot;gcc ${cflags} test.c -o test&quot;).
</code></pre>
<p>In this rule, the variable <code>cflags</code> is not <em>grounded</em>, as it only appears as an argument of a built-in predicate <code>run</code> that expects an instantiated variable. Thus, this is an invalid Datalog program, since it violates standard Datalog's safety conditions that do not permit non-grounded variables. A workaround of this problem is to define possible compilation flags using a dedicated predicate:</p>
<pre><code class="language-Modusfile">supported_flags(&quot;-g&quot;).
supported_flags(&quot;&quot;).

a(cflags) :-
    supported_flags(cflags),
    from(&quot;gcc:latest&quot;),
    copy(&quot;.&quot;, &quot;.&quot;),
    run(f&quot;gcc ${cflags} test.c -o test&quot;).
</code></pre>
<p>However, GCC accepts a large number of flags, so it would impractical to list all accepted flags in the Modus program. Instead, it would be natural to allow users to use this program to build the goal <code>app(&quot;-g&quot;)</code>, since the argument of <code>run</code> can then be inferred from the goal.</p>
<p>To enable such usage scenarios, we relaxed the safety conditions by allowing user-defined predicates with non-grounded variables. At the same time, we introduced the new restriction that, during evaluation, we defer the evaluation of these predicates until all of their arguments are bound to constants. Doing so enabled us to support the usage scenario above without sacrificing Datalog's safety.</p>
<p>For user-defined predicates, variables which do not appear in the body have to be initialised before the rule can be applied. For example, for the script:</p>
<pre><code class="language-Modusfile">a(X) :-
  from(&quot;alpine&quot;),
  run(&quot;echo Hello&quot;).
</code></pre>
<p>A query like <code>a(&quot;foo&quot;)</code>, where <code>&quot;foo&quot;</code> is a arbitrary string constant, would build the same image, but the query <code>a(X)</code> is not allowed. This ensures that each resulting image is mapped to a constant literal like <code>a(&quot;foo&quot;)</code>.</p>
<h3 id="proof-optimality"><a class="header" href="#proof-optimality">Proof Optimality</a></h3>
<p>A Datalog fact can be inferred from other facts in multiple ways and therefore multiple proof trees may exists. Thus, an image defined in Modus may also be built using different build DAGs. Modus searches for an optimal proof, that is a proof with a minimal cost. The cost of a proof is the number of layers in the build DAG.</p>
<p>To illustrate proof optimality, consider again this build script:</p>
<pre><code class="language-Modusfile">a(mode) :-
    (
        mode = &quot;production&quot;,
        from(&quot;alpine&quot;),
        a(&quot;development&quot;)::copy(&quot;/app&quot;, &quot;/app&quot;)
    ;
        mode = &quot;development&quot;,
        from(&quot;gcc&quot;),
        copy(&quot;.&quot;, &quot;/app&quot;),
        run(&quot;cd /app &amp;&amp; make&quot;)
    )::set_workdir(&quot;/app&quot;).
</code></pre>
<p>For the query <code>a(&quot;production&quot;)</code>, Modus will compute the following build trees:</p>
<pre><code>a(&quot;production&quot;)
╞══ from(&quot;alpine&quot;)
└── a(&quot;development&quot;)::copy(&quot;/app&quot;, &quot;/app&quot;)
    ╞══ from(&quot;gcc&quot;)
    ├── copy(&quot;.&quot;, &quot;/app&quot;)
    └── run(&quot;cd /app &amp;&amp; make&quot;)
</code></pre>
<p>However, if we add a new rule that uses a cached development image from a registry</p>
<pre><code class="language-Modusfile">a(&quot;development&quot;) :- from(&quot;myregistry.domain.com/app:1.1-dev&quot;).
</code></pre>
<p>then the result of the query <code>a(&quot;production&quot;)</code> will become</p>
<pre><code>a(&quot;production&quot;)
╞══ from(&quot;alpine&quot;)
└── a(&quot;development&quot;)::copy(&quot;/app&quot;, &quot;/app&quot;)
    ╘══ from(&quot;myregistry.domain.com/app:1.1-dev&quot;)
</code></pre>
<p>because this tree involves fewer layer operations than the original one.</p>
<p>There may be situations when several minimal proofs of the same cost exist. In this case, Modus chooses one in an unspecified way. Although Modus is deterministic, reordering rules may cause Modus to generate a different minimal proof. To avoid non-determinism, it is recommend to avoid rules with uncontrolled choice:</p>
<pre><code class="language-Modusfile">a :- b; c.
</code></pre>
<p>Instead, this rule can be re-written with an auxiliary variable to control the choice:</p>
<pre><code class="language-Modusfile">a(choice) :-
    choice = &quot;left&quot;, b;
    choice = &quot;right&quot;, c.
</code></pre>
<p>Modus produces a warning when the build graph construction is non-deterministic.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="command-line-tool"><a class="header" href="#command-line-tool">Command Line Tool</a></h1>
<p>The following screencast demonstrates a simple but complete workflow of proving, building, tagging and running images.
<a href="https://asciinema.org/a/DelA6wHXgWGaFUhPUnZAdFZDw"><img src="https://asciinema.org/a/DelA6wHXgWGaFUhPUnZAdFZDw.svg" alt="asciicast" /></a></p>
<h2 id="modus-build"><a class="header" href="#modus-build"><code>modus build</code></a></h2>
<p>Much like <code>docker build</code>, the <code>modus build</code> command builds a Modusfile.</p>
<p><strong>Syntax</strong>: <code>modus build [options] &lt;context&gt; &lt;query&gt;</code></p>
<p><code>context</code> is a directory containing all files (including the Modusfile) to send to Docker for building. <code>.dockerignore</code> can be used to exclude files in the same way as <code>docker build</code>.</p>
<p><code>query</code> is the target literal to build.</p>
<p><strong>Options</strong>:</p>
<p><code>-f &lt;modusfile&gt;</code>: Allows building something other than <code>./Modusfile</code>.</p>
<p><code>--json</code> or <code>--json=&lt;file&gt;</code>: Outputs the build results as JSON.</p>
<p>In the first case, the output are written to stdout. In the second case, the output are written to the file specified.</p>
<p>An example JSON output looks like this:</p>
<pre><code class="language-json">[
  {
    &quot;predicate&quot;: &quot;all&quot;,
    &quot;args&quot;: [
      &quot;frontend&quot;,
      &quot;release&quot;
    ],
    &quot;digest&quot;: &quot;sha256:595a66d80d1ef681f821e0ae92fd785b437ad2fbd5c564da093f588e37dfd65f&quot;
  }
]
</code></pre>
<p>There will be one entry for every final image built, with the applied arguments for the predicate stored in the <code>args</code> array. This could be useful for scripting in CI routines. For example, the following command runs <code>modus build</code>, then tags the produced images with <code>modus/</code> + the valuation of <code>X</code>:</p>
<pre><code class="language-sh">modus build . 'all(X, &quot;release&quot;)' --json | jq -r '.[] | .digest, (&quot;modus/&quot; + .args[0])' | xargs -L 2 docker tag
</code></pre>
<p><code>--no-cache</code>: Ignore all existing build cache. This effectively forces a complete rebuild of the image. Existing base images used in <code>from</code> clauses are <strong>not</strong> re-downloaded. To update those, use <code>docker pull</code>.</p>
<p><code>-v</code> or <code>--verbose</code>: Print all the build output. This is implemented by passing <code>--progress=plain</code> to <code>docker build</code>, which turns off the interactive progress report and instead print all the stages with numbering and their output.</p>
<p><strong>Developer options</strong>: useful for debugging Modus itself.</p>
<p><code>--docker-flags=&lt;flags&gt;</code>: Pass additional raw flags to <code>docker build</code>.</p>
<p><code>--custom-buildkit-frontend=&lt;frontend&gt;</code>: Use a custom buildkit frontend. The default is <code>ghcr.io/modus-continens/modus-buildkit-frontend:</code> + commit hash of the Modus program (embedded in binary at build time).</p>
<p><code>--image-export-concurrency &lt;integer&gt;</code>, <code>--image-resolve-concurrency &lt;number&gt;</code>: Controls the concurrency used during image export and image resolution respectively.</p>
<p>Image resolution is done at the beginning of the build, and may involves fetching metadata (and downloading the image if necessary) from the repository. Image export is the very last step of any build process, and is usually disk IO-bound, although delay may be introduced by <code>docker build</code>.</p>
<p>Defaults: <code>--image-export-concurrency=8</code>, <code>--image-resolve-concurrency=3</code>.</p>
<h2 id="modus-proof"><a class="header" href="#modus-proof"><code>modus proof</code></a></h2>
<p><code>modus proof</code> prints out proof trees based on some Modus facts/rules, and a provided goal.</p>
<p><strong>Syntax</strong>: <code>modus proof [options] &lt;context&gt; &lt;query&gt;</code></p>
<ul>
<li><code>context</code> is a directory that should contain the Modusfile that contains the facts/rules.
This is chosen to match the interface of <code>modus build</code>.</li>
<li><code>query</code> specifies the goal to prove.</li>
</ul>
<p><strong>Options</strong>:</p>
<ul>
<li><code>--compact</code>: Changes the output of proof trees, omitting logical rule resolution.</li>
<li><code>-e, --explain</code>: Prints out a structured 'explanation' of the steps taken to prove <code>&lt;query&gt;</code> during
SLD resolution. (See <code>-g</code> for a graphical version of this.)
This may be verbose.</li>
<li><code>-f &lt;modusfile&gt;</code>: Use the facts and rules of this Modusfile, instead of <code>&lt;context&gt;/Modusfile</code>.</li>
<li><code>-g, --graph</code>: Outputs DOT source for a graph of the SLD tree. This can given to <code>dot -Tpng</code> to produce
a PNG of the graph.
Recommended over <code>-e</code> for larger Modusfiles.</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </body>
</html>
